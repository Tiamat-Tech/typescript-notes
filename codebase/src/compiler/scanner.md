# Scanner

One of the smallest parts of the compiler's critical path to AST then type-checking. It exists to create a stream
of syntax tokens for use by another object. The scanner gets most of its usage via a [parser][0] instance.

## Overview

You create a Scanner instance via [`createScanner`][1], there are two main modes of scanning: Standard and JSX.
Then there are specific functions for scanning inside JSDoc comments.

First you set the text of a scanner to be your JS source code via [`setText`][2], this takes the source code and
an optional start and end range in which you want to scan. This range is an important part of what keeps
TypeScript's server mode fast via [incremental parsing][3].

At a high level, the scanner works by a having another object call [`scanner.scan`][4] this:

- Pulls out the character at the current position (`pos`) in the text
- Runs a very big switch statement against known characters which start syntax
- Then move look forwards till the end of that list of chars to decode if it's what we think it is. here's an
  example of what happens when [the character found][5] is a `!`:

  ```ts
  case CharacterCodes.exclamation:
    // Look to see if it's "!="
    if (text.charCodeAt(pos + 1) === CharacterCodes.equals) {
        // Also check if it's "!=="
        if (text.charCodeAt(pos + 2) === CharacterCodes.equals) {
            // for !== move the position forwards to the end of the symbol
            // then set the token
            return pos += 3, token = SyntaxKind.ExclamationEqualsEqualsToken;
        }
        // Move it two, set the token
        return pos += 2, token = SyntaxKind.ExclamationEqualsToken;
    }

    // Move forwards one character and set the token
    pos++;
    return token = SyntaxKind.ExclamationToken;
  ```

- A `SyntaxKind` is returned from [`scan`][4] and it's up to the scanner owner to do work with those tokens. The
  scanner keeps track of a few useful values for that:

  - `getStartPos` - where the token was started including preceding whitespace
  - `getTextPos` - the end position of the current token
  - `getTokenText` - the text between the token start and end
  - `getTokenValue` - some syntax contains a value which can be represented as a string, a good example is
    literally a string. The `"` or `'` are not included in the value.

## Trivia

When creating a scanner you get to choose whether whitespace should be returned in the stream of tokens. This is
nearly always off, but it is used inside the [formatter][6] and for syntax highlighting via the TSServer via a
[classifier][7].

## JSX

Some of the more complicated aspects of JSX support is mostly handled back in [the parser][0], however JSX support
in the scanner [uses specific syntax tokens][8].

## Flags

One way for the scanner to keep track of scan issues, or internal state is [via `TokenFlags`][9]. Any example of
this is in scanning a number. TypeScript supports underscores in numbers `100_000`, when scanning a number literal
if it detects a `CharacterCodes._` then the flag `TokenFlags.ContainsSeparator` is set and later on that is used
to ensure the `tokenValue` is set correctly.

## Rescanning

Because the scanner is only interested in passing out tokens as it sees them, it doesn't really have a memory of
previous tokens. This means that occasionally the controlling object will need to rewind and re-run the scanner
with a different type of context. This is called rescanning.

## Example code

[Here's a scanner playground](https://5d39df23407c626e65aee7ef--ts-scanner-tokens.netlify.com) - adding TypeScript
will show you the tokens generated by a single scanner. It's worth noting that this doesn't represent that
_actual_ results of the scanner when using TypeScript, because the parser controls re-scanning and this playground
doesn't do that.

<!-- prettier-ignore-start -->
[0]: ./parser.md
[1]: <src/compiler/scanner.ts - export function createScanner>
[2]: <src/compiler/scanner.ts - function setText(>
[3]: GLOSSARY.md#incremental-parsing
[4]: <src/compiler/scanner.ts - function scan(>
[5]: <src/compiler/scanner.ts - case CharacterCodes.exclamation>
[6]: ./formatter.md
[7]: <src/services/classifier.ts - function createClassifier>
[8]: <src/compiler/types.ts - type JsxTokenSyntaxKind>
[9]: <src/compiler/types.ts - export const enum TokenFlags>
<!-- prettier-ignore-end -->
